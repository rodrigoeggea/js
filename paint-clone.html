<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Clone do Paint</title>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #toolbar {
      display: flex;
      align-items: center;
      background: #eee;
      padding: 10px;
      border-bottom: 1px solid #ccc;
      flex-wrap: wrap;
    }
    #toolbar > * { margin: 5px; }
    .color-swatch {
      width: 20px;
      height: 20px;
      border: 1px solid #000;
      cursor: pointer;
      margin: 1px;
    }
    .selected { outline: 2px solid black; }
    #colorPalette {
      display: grid;
      grid-template-columns: repeat(10, 20px);
      gap: 2px;
    }
    #currentColorPreview {
      width: 30px;
      height: 30px;
      border: 2px solid black;
      background-color: black;
      cursor: pointer;
    }
    .tool-button {
      padding: 5px 10px;
      border: 1px solid #333;
      background-color: #ddd;
      cursor: pointer;
      border-radius: 4px;
    }
    .tool-button.active { background-color: #bbb; }
    #colorPicker { display: none; }
    canvas {
      border: 1px solid #000;
      cursor: crosshair;
      display: block;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <div id="colorPalette"></div>
    <div style="display: flex; flex-direction: column; align-items: center;">
      <div id="currentColorPreview" title="Clique para escolher uma cor personalizada"></div>
      <button class="tool-button" data-tool="eyedropper" style="margin-top: 4px;">ğŸ©º</button>
    </div>
    <input type="color" id="colorPicker">
    <label>Espessura: <input type="range" id="brushSize" min="1" max="30" value="5"></label>
    <div style="display: flex; flex-wrap: wrap; gap: 4px; align-items: center;">
      <button class="tool-button" data-tool="pencil">âœï¸</button>
      <button class="tool-button" data-tool="eraser">ğŸ§½</button>
      <button class="tool-button" data-tool="bucket">ğŸ¨</button>
      <button class="tool-button" data-tool="circle">âšª</button>
      <button class="tool-button" data-tool="rectangle">â¬›</button>
      <button class="tool-button" data-tool="triangle">ğŸ”º</button>
      <button class="tool-button" data-tool="line">ğŸ“</button>
    </div>
    <button id="clearButton" class="tool-button">ğŸ—‘ï¸</button>
    <button id="openButton" class="tool-button">ğŸ“‚</button>
    <button id="undoButton" class="tool-button">â†©ï¸</button>
    <button id="redoButton" class="tool-button">â†ªï¸</button>
    <button id="saveButton" class="tool-button">ğŸ’¾</button>
    <input type="file" id="fileInput" accept="image/*" style="display:none">
  </div>
  <canvas id="paintCanvas" width="800" height="600"></canvas>
  <script>
    const canvas = document.getElementById("paintCanvas");
    const ctx = canvas.getContext("2d");
    let painting = false;
    let currentColor = "#000000";
    let currentTool = "pencil";
    let startX = 0, startY = 0, currentX = 0, currentY = 0;
    let savedImage = null;
    let history = [], redoStack = [];

    const colorPalette = document.getElementById("colorPalette");
    const colorPreview = document.getElementById("currentColorPreview");
    const colorPicker = document.getElementById("colorPicker");

    function saveHistory() {
      history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
      if (history.length > 50) history.shift();
      redoStack = [];
    }

    const colors = [
      "#000000", "#808080", "#800000", "#FF0000", "#FFA500", "#FFFF00", "#008000", "#00FFFF", "#0000FF", "#800080",
      "#FFFFFF", "#C0C0C0", "#FFC0CB", "#FFD700", "#EEE8AA", "#ADFF2F", "#ADD8E6", "#87CEEB", "#6495ED", "#D8BFD8",
      "#F5F5F5", "#E0E0E0", "#D2B48C", "#F4A460", "#DAA520", "#90EE90", "#B0E0E6", "#B0C4DE", "#D3D3D3", "#F0F8FF"
    ];

    colors.forEach(color => {
      const swatch = document.createElement("div");
      swatch.className = "color-swatch";
      swatch.style.backgroundColor = color;
      swatch.addEventListener("click", () => {
        currentColor = color;
        colorPreview.style.backgroundColor = color;
      });
      colorPalette.appendChild(swatch);
    });

    document.querySelectorAll(".tool-button[data-tool]").forEach(btn => {
      btn.addEventListener("click", () => {
        document.querySelectorAll(".tool-button[data-tool]").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentTool = btn.dataset.tool;
      });
    });

    colorPreview.addEventListener("click", () => colorPicker.click());
    colorPicker.addEventListener("input", () => {
      currentColor = colorPicker.value;
      colorPreview.style.backgroundColor = currentColor;
    });

    function startPosition(e) {
      const rect = canvas.getBoundingClientRect();
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;

      if (["rectangle", "circle", "line", "triangle"].includes(currentTool)) {
        savedImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
      } else {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
      }
      painting = true;
    }

    function draw(e) {
      if (!painting) return;
      const rect = canvas.getBoundingClientRect();
      currentX = e.clientX - rect.left;
      currentY = e.clientY - rect.top;
      ctx.lineWidth = document.getElementById("brushSize").value;
      ctx.strokeStyle = currentColor;

      if (currentTool === "pencil" || currentTool === "eraser") {
        ctx.lineCap = "round";
        ctx.strokeStyle = currentTool === "eraser" ? "#FFFFFF" : currentColor;
        ctx.lineTo(currentX, currentY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(currentX, currentY);
      } else if (savedImage) {
        ctx.putImageData(savedImage, 0, 0);
        if (currentTool === "rectangle") ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
        else if (currentTool === "circle") {
          const width = currentX - startX, height = currentY - startY;
          const centerX = startX + width / 2, centerY = startY + height / 2;
          const radius = Math.sqrt((width / 2) ** 2 + (height / 2) ** 2);
          ctx.beginPath(); ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI); ctx.stroke();
        } else if (currentTool === "line") {
          ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(currentX, currentY); ctx.stroke();
        } else if (currentTool === "triangle") {
          ctx.beginPath();
          ctx.moveTo((startX + currentX) / 2, startY);
          ctx.lineTo(startX, currentY);
          ctx.lineTo(currentX, currentY);
          ctx.closePath(); ctx.stroke();
        }
      }
    }

    function endPosition() {
      painting = false;
      ctx.beginPath();
    }

    function hexToRgba(hex) {
      const bigint = parseInt(hex.replace('#', ''), 16);
      return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255, 255];
    }

    function floodFill(x, y, fillColor) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const width = imageData.width;
      const stack = [[x, y]];
      const startIdx = (y * width + x) * 4;
      const startColor = data.slice(startIdx, startIdx + 4);
      if (JSON.stringify(startColor) === JSON.stringify(fillColor)) return;
      while (stack.length > 0) {
        const [cx, cy] = stack.pop();
        const idx = (cy * width + cx) * 4;
        if (data[idx] === startColor[0] && data[idx + 1] === startColor[1] && data[idx + 2] === startColor[2] && data[idx + 3] === startColor[3]) {
          data[idx] = fillColor[0]; data[idx + 1] = fillColor[1]; data[idx + 2] = fillColor[2]; data[idx + 3] = fillColor[3];
          if (cx > 0) stack.push([cx - 1, cy]);
          if (cx < width - 1) stack.push([cx + 1, cy]);
          if (cy > 0) stack.push([cx, cy - 1]);
          if (cy < canvas.height - 1) stack.push([cx, cy + 1]);
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }

    canvas.addEventListener("mousedown", e => { saveHistory(); startPosition(e); });
    canvas.addEventListener("mousemove", draw);
    canvas.addEventListener("mouseup", endPosition);
    canvas.addEventListener("click", e => {
      if (currentTool === "bucket") {
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor(e.clientX - rect.left);
        const y = Math.floor(e.clientY - rect.top);
        floodFill(x, y, hexToRgba(currentColor));
      }
    });

    document.getElementById("clearButton").addEventListener("click", () => {
      saveHistory(); ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

    document.getElementById("undoButton").addEventListener("click", () => {
      if (history.length > 0) {
        redoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        ctx.putImageData(history.pop(), 0, 0);
      }
    });

    document.getElementById("redoButton").addEventListener("click", () => {
      if (redoStack.length > 0) {
        const imageData = redoStack.pop();
        history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        ctx.putImageData(imageData, 0, 0);
      }
    });

    document.getElementById("saveButton").addEventListener("click", () => {
      const tmp = document.createElement("canvas");
      tmp.width = canvas.width;
      tmp.height = canvas.height;
      const tctx = tmp.getContext("2d");
      tctx.fillStyle = "#FFFFFF";
      tctx.fillRect(0, 0, tmp.width, tmp.height);
      tctx.drawImage(canvas, 0, 0);
      const link = document.createElement("a");
      link.download = "desenho.png";
      link.href = tmp.toDataURL("image/png");
      link.click();
    });

    document.getElementById("openButton").addEventListener("click", () => document.getElementById("fileInput").click());
    document.getElementById("fileInput").addEventListener("change", (e) => {
      saveHistory();
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        const img = new Image();
        img.onload = () => {
          const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
          const w = img.width * scale, h = img.height * scale;
          const x = (canvas.width - w) / 2, y = (canvas.height - h) / 2;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, x, y, w, h);
        };
        img.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    });
  </script>
</body>
</html>
